./App.tsx
---
import React, { useState, useCallback } from 'react';
import { InputSection } from './components/InputSection';
import { VisualizationSection } from './components/VisualizationSection';
import { MathematicalSummary } from './components/MathematicalSummary';
import type { FractionInput, CalculationData, ValidatedFraction } from './types';
import { MAX_DENOMINATOR_PRODUCT, MAX_INDIVIDUAL_DENOMINATOR, TEXT_COLOR_DARK } from './constants';

const App: React.FC = () => {
  const initialFraction1: FractionInput = { num: '1', den: '2' };
  const initialFraction2: FractionInput = { num: '1', den: '3' };

  const [fraction1, setFraction1] = useState<FractionInput>(initialFraction1);
  const [fraction2, setFraction2] = useState<FractionInput>(initialFraction2);
  const [errors, setErrors] = useState<{ f1Num?: string; f1Den?: string; f2Num?: string; f2Den?: string; general?: string }>({});
  const [calculationData, setCalculationData] = useState<CalculationData | null>(null);
  const [isCalculating, setIsCalculating] = useState<boolean>(false);
  const [showResults, setShowResults] = useState<boolean>(false);

  const handleFractionChange = useCallback((id: 'f1' | 'f2', field: 'num' | 'den', value: string) => {
    const setter = id === 'f1' ? setFraction1 : setFraction2;
    setter(prev => ({ ...prev, [field]: value }));
    if (showResults) {
        // If user changes input after a calculation, effectively reset visualization part by hiding it
        setShowResults(false);
        setCalculationData(null); 
        // Errors are cleared on next submit, or if user resets explicitly
    }
  }, [showResults]);

  const validateAndCalculate = (): CalculationData | null => {
    const newErrors: typeof errors = {};
    const parsedF1Num = parseInt(fraction1.num, 10);
    const parsedF1Den = parseInt(fraction1.den, 10);
    const parsedF2Num = parseInt(fraction2.num, 10);
    const parsedF2Den = parseInt(fraction2.den, 10);

    if (isNaN(parsedF1Num) || fraction1.num === '') newErrors.f1Num = 'Must be integer';
    if (isNaN(parsedF1Den) || fraction1.den === '') newErrors.f1Den = 'Must be integer';
    if (isNaN(parsedF2Num) || fraction2.num === '') newErrors.f2Num = 'Must be integer';
    if (isNaN(parsedF2Den) || fraction2.den === '') newErrors.f2Den = 'Must be integer';

    if (Object.keys(newErrors).length > 0) {
      setErrors(newErrors);
      return { isError: true, errorMessage: "Invalid inputs.", f1: {} as ValidatedFraction, f2: {} as ValidatedFraction } as CalculationData;
    }

    if (parsedF1Den <= 0) newErrors.f1Den = 'Must be > 0';
    if (parsedF2Den <= 0) newErrors.f2Den = 'Must be > 0';
    
    if (parsedF1Den > MAX_INDIVIDUAL_DENOMINATOR) newErrors.f1Den = `Max ${MAX_INDIVIDUAL_DENOMINATOR}`;
    if (parsedF2Den > MAX_INDIVIDUAL_DENOMINATOR) newErrors.f2Den = `Max ${MAX_INDIVIDUAL_DENOMINATOR}`;

    if (parsedF1Num < 0) newErrors.f1Num = 'Must be >= 0';
    if (parsedF2Num < 0) newErrors.f2Num = 'Must be >= 0';

    if (parsedF1Num > parsedF1Den) newErrors.f1Num = 'a ≤ b';
    if (parsedF2Num > parsedF2Den) newErrors.f2Num = 'x ≤ y';
    
    if (Object.keys(newErrors).length > 0) {
      setErrors(newErrors);
      return { isError: true, errorMessage: "Validation errors.", f1: {} as ValidatedFraction, f2: {} as ValidatedFraction } as CalculationData;
    }
    
    const f1Val: ValidatedFraction = { num: parsedF1Num, den: parsedF1Den };
    const f2Val: ValidatedFraction = { num: parsedF2Num, den: parsedF2Den };

    const commonDenominator = f1Val.den * f2Val.den;
    if (commonDenominator === 0) { // Should be caught by parsedF1Den/parsedF2Den <= 0, but good to double check
        newErrors.general = `Denominators cannot be zero.`;
        setErrors(newErrors);
        return { isError: true, errorMessage: newErrors.general, f1: f1Val, f2: f2Val } as CalculationData;
    }
    if (commonDenominator > MAX_DENOMINATOR_PRODUCT) {
      newErrors.general = `Common denominator (b*y = ${commonDenominator}) exceeds max of ${MAX_DENOMINATOR_PRODUCT}. Try smaller denominators.`;
      setErrors(newErrors);
      return { isError: true, errorMessage: newErrors.general, f1: f1Val, f2: f2Val } as CalculationData;
    }

    const f1TransformedNum = f1Val.num * f2Val.den;
    const f2TransformedNum = f2Val.num * f1Val.den;
    const sumNum = f1TransformedNum + f2TransformedNum;

    if (sumNum > commonDenominator) {
        newErrors.general = `Sum (${sumNum}/${commonDenominator}) > 1. This visualizer currently supports sums ≤ 1.`;
        setErrors(newErrors);
        return { isError: true, errorMessage: newErrors.general, f1: f1Val, f2: f2Val } as CalculationData;
    }
    
    setErrors({});
    return {
      f1: f1Val,
      f2: f2Val,
      commonDenominator,
      f1TransformedNum,
      f1TransformedDen: commonDenominator,
      f2TransformedNum,
      f2TransformedDen: commonDenominator,
      sumNum,
      sumDen: commonDenominator,
      isError: false,
    };
  };

  const handleSubmit = useCallback(() => {
    setIsCalculating(true);
    setShowResults(false); // Hide previous results immediately
    setCalculationData(null); // Clear previous data
    setErrors({}); // Clear previous errors

    // Introduce a small delay for simulate calculation if needed, or direct call
    // setTimeout(() => {
      const result = validateAndCalculate();
      setCalculationData(result);

      if (result && result.isError) {
        // Errors are already set by validateAndCalculate, showResults remains false
        setShowResults(false); 
      } else if (result) {
        setShowResults(true);
      }
      setIsCalculating(false);
    // }, 50); // Optional small delay
  }, [fraction1, fraction2]); // Dependencies include fractions to re-create callback if they change


  const handleReset = useCallback(() => {
    setFraction1(initialFraction1);
    setFraction2(initialFraction2);
    setErrors({});
    setCalculationData(null);
    setShowResults(false);
    setIsCalculating(false);
  }, []); // initialFraction1 and initialFraction2 are stable

  return (
    <div className="min-h-screen bg-slate-100 py-8 px-4 flex flex-col items-center space-y-8">
      <header className="text-center">
        <h1 className={`text-4xl font-bold text-[${TEXT_COLOR_DARK}]`}>Visual Fraction Addition</h1>
        <p className={`mt-2 text-lg text-slate-600`}>
          See how fractions are added step-by-step.
        </p>
      </header>

      <InputSection
        fraction1={fraction1}
        fraction2={fraction2}
        onFractionChange={handleFractionChange}
        onSubmit={handleSubmit}
        onReset={handleReset}
        errors={errors}
        isCalculating={isCalculating}
      />

      {showResults && calculationData && !calculationData.isError && (
        <>
          <VisualizationSection calcData={calculationData} />
          <MathematicalSummary calcData={calculationData} />
        </>
      )}
    </div>
  );
};

export default App;

---
./README.md
---
# Run and deploy your AI Studio app

This contains everything you need to run your app locally.

## Run Locally

**Prerequisites:**  Node.js


1. Install dependencies:
   `npm install`
2. Set the `GEMINI_API_KEY` in [.env.local](.env.local) to your Gemini API key
3. Run the app:
   `npm run dev`


---
./constants.ts
---
export const SQUARE_SIDE = 180; // New constant for square dimensions

export const FRACTION1_COLOR = "#a0c4ff"; // Light Blue (Pastel Blue)
export const FRACTION1_TEXT_COLOR = "#003366"; // Darker Blue for text on light blue

export const FRACTION2_COLOR = "#ffd6a5"; // Light Orange (Pastel Orange)
export const FRACTION2_TEXT_COLOR = "#805b36"; // Darker Orange for text on light orange

export const SUM_PRIMARY_COLOR = FRACTION1_COLOR; // For the first part of the sum
export const SUM_SECONDARY_COLOR = FRACTION2_COLOR; // For the second part of the sum

export const BORDER_COLOR = "#4A5568"; // Tailwind gray-600
export const GRID_LINE_COLOR = "#A0AEC0"; // Tailwind gray-400
export const TEXT_COLOR_DARK = "#2D3748"; // Tailwind gray-800
export const TEXT_COLOR_LIGHT = "#718096"; // Tailwind gray-500
export const ERROR_COLOR = "#E53E3E"; // Tailwind red-600

export const MAX_DENOMINATOR_PRODUCT = 144; // Max b*y (e.g., 12x12 grid)
export const MAX_INDIVIDUAL_DENOMINATOR = 20; // Max for b or y

export const CELL_NUMBER_FONT_SIZE = '9px'; // Font size for cell numbers


---
./index.html
---
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Visual Fraction Addition</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css"
    integrity="sha384-wcIxkf4k558AjM3Yz3BBFQUbk/zgIYC2R0QpeeYb+TwlBVMrlgLqwRjRtGZiK7ww" crossorigin="anonymous">
  <style>
    /* Custom styles for D3 transitions if needed, or for global page style */
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    /* Ensure svgs are not overly large by default if container is small */
    svg {
      max-width: 100%;
      height: auto;
    }

    .katex-display {
      /* Ensure KaTeX display mode doesn't introduce unwanted margins */
      margin: 0;
    }

    .katex {
      /* Adjust font size for KaTeX if needed globally */
      font-size: 1.8em;
      /* Example: make KaTeX slightly larger */
    }
  </style>

</head>

<body class="bg-slate-50 text-slate-800">
  <div id="root"></div>
  <script type="module" src="/index.tsx"></script>
</body>

</html>

---
./index.tsx
---

import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error("Could not find root element to mount to");
}

const root = ReactDOM.createRoot(rootElement);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
    

---
./metadata.json
---
{
  "name": "Visual Fraction Addition",
  "description": "An educational application to visually demonstrate the addition of two fractions by transforming them into equivalent fractions with a common denominator, represented by grids using D3.js.",
  "requestFramePermissions": [],
  "prompt": ""
}

---
./package.json
---
{
  "name": "visual-fraction-addition",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "deploy": "gh-pages -d dist"
  },
  "dependencies": {
    "d3": "^7.9.0",
    "katex": "0.16.10",
    "react": "^19.1.0",
    "react-dom": "^19.1.0"
  },
  "devDependencies": {
    "@types/node": "^22.14.0",
    "@types/react": "^19.1.5",
    "@types/react-dom": "^19.1.5",
    "gh-pages": "^6.3.0",
    "typescript": "~5.7.2",
    "vite": "^6.2.0"
  }
}

---
./prompt.txt
---
./App.tsx
---
import React, { useState, useCallback } from 'react';
import { InputSection } from './components/InputSection';
import { VisualizationSection } from './components/VisualizationSection';
import { MathematicalSummary } from './components/MathematicalSummary';
import type { FractionInput, CalculationData, ValidatedFraction } from './types';
import { MAX_DENOMINATOR_PRODUCT, MAX_INDIVIDUAL_DENOMINATOR, TEXT_COLOR_DARK } from './constants';

const App: React.FC = () => {
  const initialFraction1: FractionInput = { num: '1', den: '2' };
  const initialFraction2: FractionInput = { num: '1', den: '3' };

  const [fraction1, setFraction1] = useState<FractionInput>(initialFraction1);
  const [fraction2, setFraction2] = useState<FractionInput>(initialFraction2);
  const [errors, setErrors] = useState<{ f1Num?: string; f1Den?: string; f2Num?: string; f2Den?: string; general?: string }>({});
  const [calculationData, setCalculationData] = useState<CalculationData | null>(null);
  const [isCalculating, setIsCalculating] = useState<boolean>(false);
  const [showResults, setShowResults] = useState<boolean>(false);

  const handleFractionChange = useCallback((id: 'f1' | 'f2', field: 'num' | 'den', value: string) => {
    const setter = id === 'f1' ? setFraction1 : setFraction2;
    setter(prev => ({ ...prev, [field]: value }));
    if (showResults) {
        // If user changes input after a calculation, effectively reset visualization part by hiding it
        setShowResults(false);
        setCalculationData(null); 
        // Errors are cleared on next submit, or if user resets explicitly
    }
  }, [showResults]);

  const validateAndCalculate = (): CalculationData | null => {
    const newErrors: typeof errors = {};
    const parsedF1Num = parseInt(fraction1.num, 10);
    const parsedF1Den = parseInt(fraction1.den, 10);
    const parsedF2Num = parseInt(fraction2.num, 10);
    const parsedF2Den = parseInt(fraction2.den, 10);

    if (isNaN(parsedF1Num) || fraction1.num === '') newErrors.f1Num = 'Must be integer';
    if (isNaN(parsedF1Den) || fraction1.den === '') newErrors.f1Den = 'Must be integer';
    if (isNaN(parsedF2Num) || fraction2.num === '') newErrors.f2Num = 'Must be integer';
    if (isNaN(parsedF2Den) || fraction2.den === '') newErrors.f2Den = 'Must be integer';

    if (Object.keys(newErrors).length > 0) {
      setErrors(newErrors);
      return { isError: true, errorMessage: "Invalid inputs.", f1: {} as ValidatedFraction, f2: {} as ValidatedFraction } as CalculationData;
    }

    if (parsedF1Den <= 0) newErrors.f1Den = 'Must be > 0';
    if (parsedF2Den <= 0) newErrors.f2Den = 'Must be > 0';
    
    if (parsedF1Den > MAX_INDIVIDUAL_DENOMINATOR) newErrors.f1Den = `Max ${MAX_INDIVIDUAL_DENOMINATOR}`;
    if (parsedF2Den > MAX_INDIVIDUAL_DENOMINATOR) newErrors.f2Den = `Max ${MAX_INDIVIDUAL_DENOMINATOR}`;

    if (parsedF1Num < 0) newErrors.f1Num = 'Must be >= 0';
    if (parsedF2Num < 0) newErrors.f2Num = 'Must be >= 0';

    if (parsedF1Num > parsedF1Den) newErrors.f1Num = 'a ≤ b';
    if (parsedF2Num > parsedF2Den) newErrors.f2Num = 'x ≤ y';
    
    if (Object.keys(newErrors).length > 0) {
      setErrors(newErrors);
      return { isError: true, errorMessage: "Validation errors.", f1: {} as ValidatedFraction, f2: {} as ValidatedFraction } as CalculationData;
    }
    
    const f1Val: ValidatedFraction = { num: parsedF1Num, den: parsedF1Den };
    const f2Val: ValidatedFraction = { num: parsedF2Num, den: parsedF2Den };

    const commonDenominator = f1Val.den * f2Val.den;
    if (commonDenominator === 0) { // Should be caught by parsedF1Den/parsedF2Den <= 0, but good to double check
        newErrors.general = `Denominators cannot be zero.`;
        setErrors(newErrors);
        return { isError: true, errorMessage: newErrors.general, f1: f1Val, f2: f2Val } as CalculationData;
    }
    if (commonDenominator > MAX_DENOMINATOR_PRODUCT) {
      newErrors.general = `Common denominator (b*y = ${commonDenominator}) exceeds max of ${MAX_DENOMINATOR_PRODUCT}. Try smaller denominators.`;
      setErrors(newErrors);
      return { isError: true, errorMessage: newErrors.general, f1: f1Val, f2: f2Val } as CalculationData;
    }

    const f1TransformedNum = f1Val.num * f2Val.den;
    const f2TransformedNum = f2Val.num * f1Val.den;
    const sumNum = f1TransformedNum + f2TransformedNum;

    if (sumNum > commonDenominator) {
        newErrors.general = `Sum (${sumNum}/${commonDenominator}) > 1. This visualizer currently supports sums ≤ 1.`;
        setErrors(newErrors);
        return { isError: true, errorMessage: newErrors.general, f1: f1Val, f2: f2Val } as CalculationData;
    }
    
    setErrors({});
    return {
      f1: f1Val,
      f2: f2Val,
      commonDenominator,
      f1TransformedNum,
      f1TransformedDen: commonDenominator,
      f2TransformedNum,
      f2TransformedDen: commonDenominator,
      sumNum,
      sumDen: commonDenominator,
      isError: false,
    };
  };

  const handleSubmit = useCallback(() => {
    setIsCalculating(true);
    setShowResults(false); // Hide previous results immediately
    setCalculationData(null); // Clear previous data
    setErrors({}); // Clear previous errors

    // Introduce a small delay for simulate calculation if needed, or direct call
    // setTimeout(() => {
      const result = validateAndCalculate();
      setCalculationData(result);

      if (result && result.isError) {
        // Errors are already set by validateAndCalculate, showResults remains false
        setShowResults(false); 
      } else if (result) {
        setShowResults(true);
      }
      setIsCalculating(false);
    // }, 50); // Optional small delay
  }, [fraction1, fraction2]); // Dependencies include fractions to re-create callback if they change


  const handleReset = useCallback(() => {
    setFraction1(initialFraction1);
    setFraction2(initialFraction2);
    setErrors({});
    setCalculationData(null);
    setShowResults(false);
    setIsCalculating(false);
  }, []); // initialFraction1 and initialFraction2 are stable

  return (
    <div className="min-h-screen bg-slate-100 py-8 px-4 flex flex-col items-center space-y-8">
      <header className="text-center">
        <h1 className={`text-4xl font-bold text-[${TEXT_COLOR_DARK}]`}>Visual Fraction Addition</h1>
        <p className={`mt-2 text-lg text-slate-600`}>
          See how fractions are added step-by-step.
        </p>
      </header>

      <InputSection
        fraction1={fraction1}
        fraction2={fraction2}
        onFractionChange={handleFractionChange}
        onSubmit={handleSubmit}
        onReset={handleReset}
        errors={errors}
        isCalculating={isCalculating}
      />

      {showResults && calculationData && !calculationData.isError && (
        <>
          <VisualizationSection calcData={calculationData} />
          <MathematicalSummary calcData={calculationData} />
        </>
      )}
    </div>
  );
};

export default App;

---
./README.md
---
# Run and deploy your AI Studio app

This contains everything you need to run your app locally.

## Run Locally

**Prerequisites:**  Node.js


1. Install dependencies:
   `npm install`
2. Set the `GEMINI_API_KEY` in [.env.local](.env.local) to your Gemini API key
3. Run the app:
   `npm run dev`


---
./constants.ts
---
export const SQUARE_SIDE = 180; // New constant for square dimensions

export const FRACTION1_COLOR = "#a0c4ff"; // Light Blue (Pastel Blue)
export const FRACTION1_TEXT_COLOR = "#003366"; // Darker Blue for text on light blue

export const FRACTION2_COLOR = "#ffd6a5"; // Light Orange (Pastel Orange)
export const FRACTION2_TEXT_COLOR = "#805b36"; // Darker Orange for text on light orange

export const SUM_PRIMARY_COLOR = FRACTION1_COLOR; // For the first part of the sum
export const SUM_SECONDARY_COLOR = FRACTION2_COLOR; // For the second part of the sum

export const BORDER_COLOR = "#4A5568"; // Tailwind gray-600
export const GRID_LINE_COLOR = "#A0AEC0"; // Tailwind gray-400
export const TEXT_COLOR_DARK = "#2D3748"; // Tailwind gray-800
export const TEXT_COLOR_LIGHT = "#718096"; // Tailwind gray-500
export const ERROR_COLOR = "#E53E3E"; // Tailwind red-600

export const MAX_DENOMINATOR_PRODUCT = 144; // Max b*y (e.g., 12x12 grid)
export const MAX_INDIVIDUAL_DENOMINATOR = 20; // Max for b or y

export const CELL_NUMBER_FONT_SIZE = '9px'; // Font size for cell numbers


---
./index.html
---
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Visual Fraction Addition</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css"
    integrity="sha384-wcIxkf4k558AjM3Yz3BBFQUbk/zgIYC2R0QpeeYb+TwlBVMrlgLqwRjRtGZiK7ww" crossorigin="anonymous">
  <style>
    /* Custom styles for D3 transitions if needed, or for global page style */
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    /* Ensure svgs are not overly large by default if container is small */
    svg {
      max-width: 100%;
      height: auto;
    }

    .katex-display {
      /* Ensure KaTeX display mode doesn't introduce unwanted margins */
      margin: 0;
    }

    .katex {
      /* Adjust font size for KaTeX if needed globally */
      font-size: 1.8em;
      /* Example: make KaTeX slightly larger */
    }
  </style>

</head>

<body class="bg-slate-50 text-slate-800">
  <div id="root"></div>
  <script type="module" src="/index.tsx"></script>
</body>

</html>

---
./index.tsx
---

import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error("Could not find root element to mount to");
}

const root = ReactDOM.createRoot(rootElement);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
    

---
./metadata.json
---
{
  "name": "Visual Fraction Addition",
  "description": "An educational application to visually demonstrate the addition of two fractions by transforming them into equivalent fractions with a common denominator, represented by grids using D3.js.",
  "requestFramePermissions": [],
  "prompt": ""
}

---
./package.json
---
{
  "name": "visual-fraction-addition",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "deploy": "gh-pages -d dist"
  },
  "dependencies": {
    "d3": "^7.9.0",
    "katex": "0.16.10",
    "react": "^19.1.0",
    "react-dom": "^19.1.0"
  },
  "devDependencies": {
    "@types/node": "^22.14.0",
    "@types/react": "^19.1.5",
    "@types/react-dom": "^19.1.5",
    "gh-pages": "^6.3.0",
    "typescript": "~5.7.2",
    "vite": "^6.2.0"
  }
}

---


---
./tsconfig.json
---
{
  "compilerOptions": {
    "target": "ES2020",
    "experimentalDecorators": true,
    "useDefineForClassFields": false,
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "allowJs": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true,

    "paths": {
      "@/*" :  ["./*"]
    }
  }
}


---
./types.ts
---
export interface FractionInput {
  num: string;
  den: string;
}

export interface ValidatedFraction {
  num: number;
  den: number;
}

export interface CalculationData {
  f1: ValidatedFraction;
  f2: ValidatedFraction;
  commonDenominator: number;
  f1TransformedNum: number; // a*y
  f1TransformedDen: number; // b*y
  f2TransformedNum: number; // x*b
  f2TransformedDen: number; // y*b (same as b*y)
  sumNum: number;
  sumDen: number; // b*y
  isError: boolean;
  errorMessage?: string;
}

export interface ShadingSegment {
  count: number; // For column-based: number of columns. For sequential: number of cells.
  color: string;
  id: string; // for d3 key
  label?: string; // Optional label for the segment for debugging or future use
}

export interface FractionVisualProps {
  idSuffix: string;
  baseWidth: number; // Will be SQUARE_SIDE
  baseHeight: number; // Will be SQUARE_SIDE
  cols: number; // Logical columns of the underlying grid structure
  rows: number; // Logical rows of the underlying grid structure
  shadingSegments: ShadingSegment[];
  isColumnBasedShading?: boolean; // If true, segment.count refers to columns to shade. Else, sequential cells.
  showCellNumbers?: boolean; // If true, numbers cells ordinally
  rotationAngle?: 0 | 90; // Rotation angle for the grid
  numberingOrder?: 'ltr-ttb' | 'ttb-ltr'; //ltr-ttb: left-to-right, then top-to-bottom. ttb-ltr: top-to-bottom, then left-to-right.
  cellNumberingDenominator?: number; // Denominator for fractional cell numbering (e.g., N in X/N)
}

// Inform TypeScript about the katex library loaded globally via CDN/importmap
declare global {
  interface Window {
    katex: any;
  }
  const katex: any;
}


---
./vite.config.ts
---
import path from 'path';
import { defineConfig, loadEnv } from 'vite';

export default defineConfig(({ mode }) => {
    const env = loadEnv(mode, '.', '');

    return {
        // Add the base path here
        base: mode === 'production' ? '/fraction_addition_visualisation/' : '/', // Specific for your repo
        define: {
            'process.env.API_KEY': JSON.stringify(env.GEMINI_API_KEY),
            'process.env.GEMINI_API_KEY': JSON.stringify(env.GEMINI_API_KEY)
        },
        resolve: {
            alias: {
                '@': path.resolve(__dirname, '.'),
            }
        }
    };
});

---
./components/FractionVisual.tsx
---

import React, { useEffect, useRef } from 'react';
import * as d3 from 'd3';
import type { FractionVisualProps, ShadingSegment } from '../types';
import {
  BORDER_COLOR,
  GRID_LINE_COLOR,
  CELL_NUMBER_FONT_SIZE,
  FRACTION1_COLOR,
  FRACTION1_TEXT_COLOR,
  FRACTION2_COLOR,
  FRACTION2_TEXT_COLOR,
  TEXT_COLOR_DARK
} from '../constants';

const ANIMATION_DURATION = 1000; // Animation duration in ms

const FractionVisual: React.FC<FractionVisualProps> = ({
  idSuffix,
  baseWidth,
  baseHeight,
  cols: logicalCols,
  rows: logicalRows,
  shadingSegments,
  isColumnBasedShading = false,
  showCellNumbers = true,
  rotationAngle = 0,
  numberingOrder = 'ltr-ttb',
  cellNumberingDenominator,
}) => {
  const svgRef = useRef<SVGSVGElement>(null);
  const prevRotationAngleRef = useRef<number>(rotationAngle);
  const initialRenderRef = useRef<boolean>(true);

  useEffect(() => {
    if (!svgRef.current || logicalCols <= 0 || logicalRows <= 0) return;

    const svg = d3.select(svgRef.current);
    svg.selectAll("*").remove(); // Clear previous rendering

    const DIAGONAL = Math.hypot(baseWidth, baseHeight);

    svg.attr('width', DIAGONAL)
       .attr('height', DIAGONAL)
       .attr('viewBox', `0 0 ${DIAGONAL} ${DIAGONAL}`)
       .style('overflow', 'visible'); // Ensure content isn't clipped if it somehow exceeds DIAGONAL, though it shouldn't

    // This group is static, establishes the center point of the SVG as (0,0) for its children
    const canvasGroup = svg.append("g")
      .attr("id", `canvas-group-${idSuffix}`)
      .attr("transform", `translate(${DIAGONAL / 2}, ${DIAGONAL / 2})`);

    // This group contains the visual square and will be rotated.
    // It's drawn centered around canvasGroup's origin.
    const mainGroup = canvasGroup.append("g").attr("id", `fraction-group-${idSuffix}`);
    
    const actualCellWidth = baseWidth / logicalCols;
    const actualCellHeight = baseHeight / logicalRows;

    const fromAngle = initialRenderRef.current ? rotationAngle : prevRotationAngleRef.current;
    
    // Initial transform for mainGroup (content group)
    // Rotation happens around (0,0) because it's already centered by canvasGroup's translation
    mainGroup.attr("transform", `rotate(${fromAngle}, 0, 0)`);

    // Animate main group rotation if angle changes
    if (fromAngle !== rotationAngle && !initialRenderRef.current) {
      mainGroup.transition()
        .duration(ANIMATION_DURATION)
        .ease(d3.easeLinear)
        .attr("transform", `rotate(${rotationAngle}, 0, 0)`);
    }

    // Border for the entire grid - drawn centered around mainGroup's (0,0)
    mainGroup.append("rect")
      .attr("x", -baseWidth / 2)
      .attr("y", -baseHeight / 2)
      .attr("width", baseWidth)
      .attr("height", baseHeight)
      .attr("fill", "none")
      .attr("stroke", BORDER_COLOR)
      .attr("stroke-width", 2);

    type CellMeta = { 
      x: number; y: number; // Top-left of cell relative to mainGroup's centered origin
      colIdx: number; rowIdx: number; logicalCellIdx: number 
    };
    const cellData: Array<CellMeta> = [];
    const gridTopLeftX = -baseWidth / 2;
    const gridTopLeftY = -baseHeight / 2;

    for (let r = 0; r < logicalRows; r++) {
      for (let c = 0; c < logicalCols; c++) {
        cellData.push({
          x: gridTopLeftX + c * actualCellWidth,
          y: gridTopLeftY + r * actualCellHeight,
          colIdx: c, 
          rowIdx: r, 
          logicalCellIdx: r * logicalCols + c, 
        });
      }
    }
    
    const determineCellFill = (
      dataCell: CellMeta,
      segments: ShadingSegment[],
    ): string => {
      if (!segments || segments.length === 0) return "transparent";
      if (isColumnBasedShading) {
        const segment = segments[0]; 
        const originalColsToShade = segment.count;
        if (dataCell.colIdx < originalColsToShade) {
          return segment.color;
        }
      } else { 
        let cumulativeShadedCells = 0;
        for (const segment of segments) {
          if (dataCell.logicalCellIdx >= cumulativeShadedCells && dataCell.logicalCellIdx < cumulativeShadedCells + segment.count) {
            return segment.color;
          }
          cumulativeShadedCells += segment.count;
        }
      }
      return "transparent";
    };

    mainGroup.selectAll(`.cell-${idSuffix}`)
      .data(cellData, (d) => `cell-${idSuffix}-r${(d as CellMeta).rowIdx}-c${(d as CellMeta).colIdx}`)
      .join("rect")
      .attr("class", `cell-${idSuffix}`)
      .attr("x", d => d.x)
      .attr("y", d => d.y)
      .attr("width", actualCellWidth)
      .attr("height", actualCellHeight)
      .attr("stroke", GRID_LINE_COLOR)
      .attr("stroke-width", 0.5)
      .attr("fill", d => determineCellFill(d, shadingSegments));

    if (logicalCols > 1) {
      mainGroup.selectAll(`.vline-${idSuffix}`)
        .data(d3.range(1, logicalCols))
        .join("line")
        .attr("class", `vline-${idSuffix}`)
        .attr("x1", d => gridTopLeftX + d * actualCellWidth)
        .attr("x2", d => gridTopLeftX + d * actualCellWidth)
        .attr("y1", gridTopLeftY)
        .attr("y2", gridTopLeftY + baseHeight)
        .attr("stroke", BORDER_COLOR) 
        .attr("stroke-width", 1);
    }

    if (logicalRows > 1) {
      mainGroup.selectAll(`.hline-${idSuffix}`)
        .data(d3.range(1, logicalRows))
        .join("line")
        .attr("class", `hline-${idSuffix}`)
        .attr("x1", gridTopLeftX)
        .attr("x2", gridTopLeftX + baseWidth)
        .attr("y1", d => gridTopLeftY + d * actualCellHeight)
        .attr("y2", d => gridTopLeftY + d * actualCellHeight)
        .attr("stroke", BORDER_COLOR) 
        .attr("stroke-width", 1);
    }

    if (showCellNumbers) {
      const textWrapperGroups = mainGroup.selectAll(`.text-wrapper-${idSuffix}`)
        .data(cellData, (d) => `text-wrapper-${idSuffix}-r${(d as CellMeta).rowIdx}-c${(d as CellMeta).colIdx}`)
        .join("g")
        .attr("class", `text-wrapper-${idSuffix}`)
        .style("pointer-events", "none"); 

      textWrapperGroups.attr("transform", d => {
        const cellCenterX = d.x + actualCellWidth / 2;
        const cellCenterY = d.y + actualCellHeight / 2;
        return `translate(${cellCenterX}, ${cellCenterY}) rotate(${-fromAngle}, 0, 0)`;
      });
      
      if (fromAngle !== rotationAngle && !initialRenderRef.current) {
        textWrapperGroups.transition()
          .duration(ANIMATION_DURATION)
          .ease(d3.easeLinear)
          .attr("transform", d => {
            const cellCenterX = d.x + actualCellWidth / 2;
            const cellCenterY = d.y + actualCellHeight / 2;
            return `translate(${cellCenterX}, ${cellCenterY}) rotate(${-rotationAngle}, 0, 0)`;
          });
      }

      textWrapperGroups.each(function(d) { 
          const wrapper = d3.select(this);
          if (wrapper.select("text").empty()) { 
              wrapper.append("text")
                  .attr("x", 0) 
                  .attr("y", 0) 
                  .attr("text-anchor", "middle")
                  .attr("dominant-baseline", "middle")
                  .style("font-size", CELL_NUMBER_FONT_SIZE)
                  .text(() => {
                      let cellDisplayNumber: number;
                      if (numberingOrder === 'ttb-ltr') {
                          cellDisplayNumber = d.colIdx * logicalRows + d.rowIdx + 1;
                      } else { 
                          cellDisplayNumber = d.rowIdx * logicalCols + d.colIdx + 1;
                      }
                      if (cellNumberingDenominator && cellNumberingDenominator > 0) {
                          return `${cellDisplayNumber}/${cellNumberingDenominator}`;
                      }
                      return cellDisplayNumber.toString();
                  })
                  .attr("fill", () => {
                      const bgColor = determineCellFill(d, shadingSegments);
                      if (bgColor === FRACTION1_COLOR) return FRACTION1_TEXT_COLOR;
                      if (bgColor === FRACTION2_COLOR) return FRACTION2_TEXT_COLOR;
                      return TEXT_COLOR_DARK;
                  });
          }
      });
    }
    
    prevRotationAngleRef.current = rotationAngle;
    initialRenderRef.current = false;

  }, [
    idSuffix, baseWidth, baseHeight, logicalCols, logicalRows, shadingSegments, 
    isColumnBasedShading, showCellNumbers, rotationAngle, numberingOrder, cellNumberingDenominator
  ]);

  // D3 will set width, height, viewBox. Parent div controls layout size.
  return (
    <svg ref={svgRef}></svg>
  );
};

export default FractionVisual;


---
./components/InputSection.tsx
---

import React from 'react';
import type { FractionInput } from '../types';
import { TEXT_COLOR_DARK, ERROR_COLOR } from '../constants';

interface InputSectionProps {
  fraction1: FractionInput;
  fraction2: FractionInput;
  onFractionChange: (id: 'f1' | 'f2', field: 'num' | 'den', value: string) => void;
  onSubmit: () => void;
  onReset: () => void;
  errors: { f1Num?: string; f1Den?: string; f2Num?: string; f2Den?: string; general?: string };
  isCalculating: boolean;
}

const InputField: React.FC<{
  id: string;
  value: string;
  onChange: (value: string) => void;
  label: string;
  error?: string;
  placeholder?: string;
}> = ({ id, value, onChange, label, error, placeholder }) => (
  <div className="flex flex-col items-center">
    <label htmlFor={id} className={`text-sm font-medium ${error ? `text-[${ERROR_COLOR}]` : `text-[${TEXT_COLOR_DARK}]`}`}>{label}</label>
    <input
      id={id}
      type="number"
      value={value}
      onChange={(e) => onChange(e.target.value)}
      placeholder={placeholder || "0"}
      className={`mt-1 w-20 p-2 text-center bg-white text-slate-900 border rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 ${error ? 'border-red-500' : 'border-gray-300'}`}
    />
    {error && <p className={`mt-1 text-xs text-[${ERROR_COLOR}]`}>{error}</p>}
  </div>
);

export const InputSection: React.FC<InputSectionProps> = ({
  fraction1,
  fraction2,
  onFractionChange,
  onSubmit,
  onReset,
  errors,
  isCalculating
}) => {
  return (
    <div className="w-full max-w-2xl mx-auto p-6 bg-white rounded-xl shadow-lg">
      <h2 className={`text-2xl font-semibold text-center mb-6 text-[${TEXT_COLOR_DARK}]`}>Enter Fractions</h2>
      
      {errors.general && (
        <div className={`mb-4 p-3 bg-red-100 border border-[${ERROR_COLOR}] text-[${ERROR_COLOR}] rounded-md text-sm`}>
          {errors.general}
        </div>
      )}

      <div className="flex items-start justify-center space-x-8">
        {/* Fraction 1 */}
        <div className="flex flex-col items-center space-y-1">
          <InputField id="f1Num" value={fraction1.num} onChange={(val) => onFractionChange('f1', 'num', val)} label="Numerator (a)" error={errors.f1Num} placeholder="a"/>
          <div className={`w-16 h-0.5 bg-[${TEXT_COLOR_DARK}] my-1`}></div>
          <InputField id="f1Den" value={fraction1.den} onChange={(val) => onFractionChange('f1', 'den', val)} label="Denominator (b)" error={errors.f1Den} placeholder="b"/>
        </div>

        {/* Operator */}
        <div className="flex items-center h-full pt-16">
          <span className={`text-4xl font-bold text-[${TEXT_COLOR_DARK}]`}>+</span>
        </div>

        {/* Fraction 2 */}
        <div className="flex flex-col items-center space-y-1">
          <InputField id="f2Num" value={fraction2.num} onChange={(val) => onFractionChange('f2', 'num', val)} label="Numerator (x)" error={errors.f2Num} placeholder="x"/>
          <div className={`w-16 h-0.5 bg-[${TEXT_COLOR_DARK}] my-1`}></div>
          <InputField id="f2Den" value={fraction2.den} onChange={(val) => onFractionChange('f2', 'den', val)} label="Denominator (y)" error={errors.f2Den} placeholder="y"/>
        </div>
      </div>

      <div className="mt-8 flex justify-center space-x-4">
        <button
          onClick={onSubmit}
          disabled={isCalculating}
          className="px-6 py-2 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50 disabled:opacity-50 transition-colors"
        >
          {isCalculating ? 'Calculating...' : 'Visualize Sum'}
        </button>
        <button
          onClick={onReset}
          disabled={isCalculating}
          className="px-6 py-2 bg-gray-200 text-gray-700 font-semibold rounded-lg shadow-md hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-opacity-50 disabled:opacity-50 transition-colors"
        >
          Reset
        </button>
      </div>
    </div>
  );
};

---
./components/KatexDisplay.tsx
---

import React, { useEffect, useRef } from 'react';
import katex from 'katex';
// CSS is loaded globally from index.html via CDN link

interface KatexDisplayProps {
  latex: string;
  block?: boolean; // for display mode vs inline
  className?: string;
}

const KatexDisplay: React.FC<KatexDisplayProps> = ({ latex, block = false, className = "" }) => {
  const containerRef = useRef<HTMLElement>(null); // Use HTMLElement as it's a common base

  useEffect(() => {
    const currentContainer = containerRef.current;
    if (currentContainer) {
      // For debugging in a live environment, one could log:
      // console.log("KatexDisplay - document.compatMode:", document.compatMode);
      try {
        katex.render(latex, currentContainer, {
          throwOnError: false, // Don't halt page on KaTeX error, allow component to display an error
          displayMode: block,
          output: 'html', 
        });
      } catch (error) {
        console.error("KaTeX rendering error:", error, "for LaTeX string:", `"${latex}"`);
        // Display a user-friendly error message in the component itself
        if (currentContainer) { // Check ref again, just in case
          currentContainer.textContent = `Error rendering LaTeX: ${latex.substring(0,30)}... (See console for details)`;
        }
      }
    }
  }, [latex, block]); // className is part of the JSX element, not a direct dep for katex.render

  // The ref is of type HTMLElement, which is compatible with both HTMLDivElement and HTMLSpanElement
  if (block) {
    // Fix: Use type assertion for the ref prop to match specific HTML element type HTMLDivElement.
    return <div ref={containerRef as React.RefObject<HTMLDivElement>} className={className} />;
  }
  // Fix: Use type assertion for the ref prop to match specific HTML element type HTMLSpanElement.
  return <span ref={containerRef as React.RefObject<HTMLSpanElement>} className={className} />;
};

export default KatexDisplay;


---
./components/MathematicalSummary.tsx
---
import React from 'react';
import type { CalculationData } from '../types';
import { TEXT_COLOR_DARK } from '../constants';
import KatexDisplay from './KatexDisplay';

interface MathematicalSummaryProps {
  calcData: CalculationData | null;
}

export const MathematicalSummary: React.FC<MathematicalSummaryProps> = ({ calcData }) => {
  if (!calcData || calcData.isError) {
    return null;
  }

  const { f1, f2, commonDenominator, f1TransformedNum, f2TransformedNum, sumNum } = calcData;

  const steps = [
    `\\frac{${f1.num}}{${f1.den}} + \\frac{${f2.num}}{${f2.den}}`,
    `= \\frac{${f1TransformedNum}}{${commonDenominator}} + \\frac{${f2TransformedNum}}{${commonDenominator}}`,
    `= \\frac{${f1TransformedNum} + ${f2TransformedNum}}{${commonDenominator}}`,
    `= \\frac{${sumNum}}{${commonDenominator}}`
  ];

  return (
    <div className={`w-full max-w-xl mx-auto mt-8 p-6 bg-white rounded-xl shadow-lg text-[${TEXT_COLOR_DARK}]`}>
      <h2 className="text-2xl font-semibold text-center mb-6">Mathematical Summary</h2>
      <div className="space-y-4 text-xl text-center"> {/* Increased space-y for better KaTeX spacing */}
        {steps.map((step, index) => (
          <div key={index} className="opacity-100 py-1"> {/* Added py-1 for vertical spacing */}
            <KatexDisplay latex={step} block={false} /> {/* block={false} for better centering if line is short */}
          </div>
        ))}
      </div>
    </div>
  );
};


---
./components/VisualizationSection.tsx
---
import React, { useState } from 'react';
import FractionVisual from './FractionVisual';
// Fix: Define VisualizationSectionProps interface
import type { CalculationData, ShadingSegment, FractionVisualProps } from '../types';
import { SQUARE_SIDE, FRACTION1_COLOR, FRACTION2_COLOR, SUM_PRIMARY_COLOR, SUM_SECONDARY_COLOR, TEXT_COLOR_DARK, BORDER_COLOR } from '../constants';
import KatexDisplay from './KatexDisplay';

const DIAGONAL_SIDE = Math.hypot(SQUARE_SIDE, SQUARE_SIDE);

const OperatorDisplay: React.FC<{ symbol: string }> = ({ symbol }) => (
  <div className={`flex items-center justify-center px-2 sm:px-4`} style={{ height: `${DIAGONAL_SIDE}px` }}>
    <KatexDisplay latex={symbol} className={`text-3xl sm:text-5xl font-bold text-[${TEXT_COLOR_DARK}]`} />
  </div>
);

const RotateButton: React.FC<{ onClick: () => void; isRotated: boolean }> = ({ onClick, isRotated }) => (
  <button
    onClick={onClick}
    className={`mt-1 px-3 py-1.5 text-xs font-medium rounded-md shadow-sm
                border border-[${BORDER_COLOR}] text-[${TEXT_COLOR_DARK}] hover:bg-gray-100
                focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50`}
    aria-label={isRotated ? "Rotate back to original orientation" : "Rotate 90 degrees clockwise"}
  >
    {isRotated ? 'Rotate Back' : 'Rotate 90°'}
  </button>
);

// Helper to create LaTeX string for a simple fraction
const fracToLatex = (num: number | string, den: number | string) => `\\frac{${num}}{${den}}`;

// Fixed size container style for the SVG
const visualFixedSizeContainerStyle: React.CSSProperties = {
  width: DIAGONAL_SIDE,
  height: DIAGONAL_SIDE,
};
const visualFixedSizeContainerClasses = "flex items-center justify-center";

// Standardized label classes
const labelTextClasses = `text-center text-lg font-semibold text-[${TEXT_COLOR_DARK}] flex items-center justify-center py-1`; // min-h to ensure consistent height

interface VisualUnitProps {
  labelAboveSquareLatex?: string;
  visualProps: Omit<FractionVisualProps, 'baseWidth' | 'baseHeight'> & Partial<Pick<FractionVisualProps, 'baseWidth' | 'baseHeight'>>;
  onRotate?: () => void;
  isRotated?: boolean;
  labelBelowSquareLatex?: string;
  isPlaceholder?: boolean;
}

const VisualUnit: React.FC<VisualUnitProps> = ({
  labelAboveSquareLatex,
  visualProps,
  onRotate,
  isRotated,
  labelBelowSquareLatex,
  isPlaceholder = false,
}) => {
  // Fix: Changed "invisible" to "hidden" for CSS visibility property.
  const unitVisibility = isPlaceholder ? 'hidden' : 'visible';
  const rotateButtonHeightApprox = '2.5rem'; // Approximate height of button + margin for spacing
  const labelHeightApprox = '2.5rem'; // min-h of labelTextClasses

  return (
    <div
      className="flex flex-col items-center space-y-0"
      style={{ minWidth: `${DIAGONAL_SIDE}px`, visibility: unitVisibility }}
      aria-hidden={isPlaceholder}
    >
      <div className={`text-center text-lg font-semibold text-[${TEXT_COLOR_DARK}] flex items-center justify-center py-1`}>
        {labelAboveSquareLatex && <KatexDisplay latex={labelAboveSquareLatex} />}
      </div>

      <div className={visualFixedSizeContainerClasses} style={visualFixedSizeContainerStyle}>
        {!isPlaceholder && (
          <FractionVisual
            {...visualProps}
            baseWidth={visualProps.baseWidth ?? SQUARE_SIDE}
            baseHeight={visualProps.baseHeight ?? SQUARE_SIDE}
          />
        )}
      </div>

      <div className={`text-center text-lg font-semibold text-[${TEXT_COLOR_DARK}] flex items-center justify-center py-1`}>
        {labelBelowSquareLatex && <KatexDisplay latex={labelBelowSquareLatex} />}
      </div>

      {/* Container for rotate button or spacer */}
      <div className="flex items-center justify-center py-1">
        {onRotate && typeof isRotated !== 'undefined' && !isPlaceholder && (
          <RotateButton onClick={onRotate} isRotated={isRotated} />
        )}
      </div>
    </div>
  );
};

// Fix: Define VisualizationSectionProps interface
interface VisualizationSectionProps {
  calcData: CalculationData;
}

export const VisualizationSection: React.FC<VisualizationSectionProps> = ({ calcData }) => {
  const [rotationF1, setRotationF1] = useState<0 | 90>(0);
  const [rotationF2, setRotationF2] = useState<0 | 90>(0);

  if (!calcData || calcData.isError) {
    return null;
  }

  const { f1, f2, commonDenominator, f1TransformedNum, f2TransformedNum, sumNum } = calcData;

  // Props for initial fraction visuals (f1a, f2a)
  const f1aVisualProps: VisualUnitProps['visualProps'] = {
    idSuffix: "f1a",
    cols: f1.den, rows: 1,
    shadingSegments: [{ count: f1.num, color: FRACTION1_COLOR, id: "f1init" }],
    isColumnBasedShading: true, showCellNumbers: true, rotationAngle: rotationF1,
    numberingOrder: 'ltr-ttb', cellNumberingDenominator: f1.den,
  };
  const f2aVisualProps: VisualUnitProps['visualProps'] = {
    idSuffix: "f2a",
    cols: f2.den, rows: 1,
    shadingSegments: [{ count: f2.num, color: FRACTION2_COLOR, id: "f2init" }],
    isColumnBasedShading: true, showCellNumbers: true, rotationAngle: rotationF2,
    numberingOrder: 'ltr-ttb', cellNumberingDenominator: f2.den,
  };

  // Props for transformed fraction visuals (f1b, f2b)
  const f1bVisualProps: VisualUnitProps['visualProps'] = {
    idSuffix: "f1b",
    cols: f1.den, rows: f2.den,
    shadingSegments: [{ count: f1.num, color: FRACTION1_COLOR, id: "f1transformed" }],
    isColumnBasedShading: true, showCellNumbers: true, rotationAngle: rotationF1,
    numberingOrder: 'ltr-ttb', cellNumberingDenominator: commonDenominator,
  };
  const f2bVisualProps: VisualUnitProps['visualProps'] = {
    idSuffix: "f2b",
    cols: f2.den, rows: f1.den,
    shadingSegments: [{ count: f2.num, color: FRACTION2_COLOR, id: "f2transformed" }],
    isColumnBasedShading: true, showCellNumbers: true, rotationAngle: rotationF2,
    numberingOrder: 'ltr-ttb', cellNumberingDenominator: commonDenominator,
  };

  // Props for sum visual
  const sumVisualProps: VisualUnitProps['visualProps'] = {
    idSuffix: "sum",
    cols: f1.den, rows: f2.den,
    shadingSegments: [
      { count: f1TransformedNum, color: SUM_PRIMARY_COLOR, id: "sumPart1" },
      { count: f2TransformedNum, color: SUM_SECONDARY_COLOR, id: "sumPart2" }
    ],
    isColumnBasedShading: false, showCellNumbers: true, rotationAngle: 0, // Sum doesn't rotate
    cellNumberingDenominator: commonDenominator,
  };

  return (
    <div className="w-full mx-auto mt-8 p-1 sm:p-3 bg-white rounded-xl shadow-xl">
      <h2 className={`text-2xl font-semibold text-center mb-6 text-[${TEXT_COLOR_DARK}]`}>Visualization</h2>

      <div className="flex flex-col items-center space-y-2">
        {/* Top Row of Visuals */}
        <div className="flex flex-row items-center justify-center w-auto mx-auto">
          <VisualUnit
            labelAboveSquareLatex={fracToLatex(f1.num, f1.den)}
            labelBelowSquareLatex=""
            visualProps={f1aVisualProps}
          />
          <OperatorDisplay symbol="+" />
          <VisualUnit
            labelAboveSquareLatex={fracToLatex(f2.num, f2.den)}
            labelBelowSquareLatex=""
            visualProps={f2aVisualProps}
          />
          <OperatorDisplay symbol="=" />
          <VisualUnit isPlaceholder={true} visualProps={{ idSuffix: "sumplaceholder", cols: 1, rows: 1, shadingSegments: [] }} /> {/* Placeholder for sum top */}
        </div>

        {/* Bottom Row of Visuals */}
        <div className="flex flex-row items-center justify-center w-auto mx-auto">
          <VisualUnit
            labelAboveSquareLatex={`\\frac{${f1.num} \\times ${f2.den}}{${f1.den} \\times ${f2.den}} = ${fracToLatex(f1TransformedNum, commonDenominator)}`}
            labelBelowSquareLatex=""
            visualProps={f1bVisualProps}
            onRotate={() => setRotationF1(prev => (prev === 0 ? 90 : 0))}
            isRotated={rotationF1 === 90}
          />
          <OperatorDisplay symbol="+" />
          <VisualUnit
            labelAboveSquareLatex={`\\frac{${f2.num} \\times ${f1.den}}{${f2.den} \\times ${f1.den}} = ${fracToLatex(f2TransformedNum, commonDenominator)}`}
            labelBelowSquareLatex=""
            visualProps={f2bVisualProps}
            onRotate={() => setRotationF2(prev => (prev === 0 ? 90 : 0))}
            isRotated={rotationF2 === 90}
          />
          <OperatorDisplay symbol="=" />
          <VisualUnit
            labelAboveSquareLatex=""
            labelBelowSquareLatex={fracToLatex(sumNum, commonDenominator)}
            visualProps={sumVisualProps}
          // Sum has its label at the bottom to align with transformed fractions' bottom labels
          />
        </div>
      </div>
    </div>
  );
};


---
